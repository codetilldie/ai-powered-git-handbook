## 第二章：Git 核心概念

本章将深入讲解 Git 的核心设计理念，包括分支、合并和远程协作等。这些是 Git 最强大、最核心的功能，理解它们是高效使用 Git 的关键。

### 2.1 理解分支 (Branch)

分支是 Git 的“杀手级特性”。它允许你从主线上分离出来，在一个独立的环境里进行开发或实验，而不会影响到主线的稳定性。

#### 使用场景

- **开发新功能**：为每个新功能创建一个独立的分支，可以保持 `master` 分支的整洁和可部署状态。
- **修复 Bug**：当线上版本出现 Bug 时，可以从对应的版本标签（Tag）或提交（Commit）创建一个修复分支，修复完成后再合并回主线。
- **实验性探索**：如果你有一个不确定的想法，可以创建一个分支进行自由探索，成功了就合并，失败了就直接丢弃，对主项目没有任何影响。

#### 命令详解

```bash
# 创建一个名为 feature-x 的新分支
git branch feature-x

# 切换到 feature-x 分支
git checkout feature-x
# 或者使用 switch (推荐，更专注)
git switch feature-x

# 创建并立即切换到新分支（常用）
git checkout -b feature-x
# 或者使用 switch (推荐)
git switch -c feature-x

# 查看所有本地分支
git branch

# 删除一个已经合并的分支
git branch -d feature-x
```

#### 底层实现：分支只是一个指针

你可能会以为创建分支是一个很“重”的操作，需要复制大量代码。但在 Git 中，创建一个分支的成本极低，几乎是瞬时完成的。

**因为一个分支，本质上只是一个指向某个特定提交（Commit）的、可移动的指针。**

- **存储位置**：这些分支指针都存储在 `.git/refs/heads/` 目录下。例如，`master` 分支就是一个名为 `master` 的文件，其内容就是 `master` 分支最新一次提交的 SHA-1 哈希值。
- **`HEAD` 指针**：在[第一章](./01-getting-started.md#13-开启你的git之旅init与clone)我们提到过 `.git/HEAD` 文件。当 `HEAD` 指向一个分支时（例如 `ref: refs/heads/master`），它告诉 Git 你当前正工作在这个分支上。所有新的提交都将发生在这个分支上，并且该分支的指针会自动向前移动到最新的提交。

所以，`git branch feature-x` 这个命令，仅仅是在 `.git/refs/heads/` 目录下新建了一个名为 `feature-x` 的文件，并将当前分支最新提交的 SHA-1 值写入其中。成本极低，速度极快。

### 2.2 合并分支：merge 与 rebase

当你在分支上的工作完成后，就需要将其整合回主线。Git 提供了两种主要方式：`git merge` 和 `git rebase`。

#### `git merge` (合并)

`merge` 会将两个分支的最新快照以及二者共同的祖先进行三方合并，并创建一个新的“合并提交”（Merge Commit）。

- **使用场景**：最常见的整合方式。当你需要将一个功能分支（如 `feature-x`）合并回开发主线（如 `develop`）时使用。
- **底层实现**：
  1. **Fast-Forward (快进) 合并**：如果你的目标分支（如 `develop`）在你创建特性分支后没有任何新的提交，那么 `merge` 会直接将 `develop` 分支的指针向前移动，指向特性分支的最新提交。这是一个“快进”操作，不会产生合并提交。
  2. **Three-Way Merge (三方合并)**：如果目标分支在你开发的同时也有了新的提交，Git 会找到两个分支的共同祖先、目标分支的最新提交、特性分支的最新提交，进行“三方合并”。它会自动创建一个新的“合并提交”，这个提交有两个父提交，分别指向被合并的两个分支。
- **优点**：保留了完全真实、精确的版本历史。你能清楚地看到每一次分支的合并记录。
- **缺点**：如果分支活动非常频繁，历史记录会变得非常复杂和混乱，充满了大量的合并提交，难以阅读。

#### `git rebase` (变基)

`rebase` 提取你在当前分支上所做的所有提交，然后将它们在目标分支的最新提交之上“重新播放”一遍。

- **使用场景**：当你希望保持一个清晰、线性的提交历史时。通常在将你的本地提交同步到远程最新代码时使用。
- **底层实现**：`rebase` 会找到两个分支的共同祖先，获取你当前分支领先于该祖先的所有提交，将它们暂存起来。然后，将当前分支的指针移动到目标分支的最新提交上，最后逐一“重新应用”刚刚暂存的那些提交。
- **优点**：创建了一个非常整洁、线性的提交历史，就像所有开发都是串行发生的一样，非常易于阅读和理解。
- **缺点**：**它重写了提交历史！** 原始的提交被抛弃，创造了内容相同但 SHA-1 值不同的新提交。

> **Rebase 的黄金法则：永远不要对已经推送到公共仓库的分支进行 rebase！**
> 因为这会重写历史，如果团队其他成员已经基于旧的历史进行了开发，当他们拉取你 rebase 后的代码时，会造成巨大的混乱。

### 2.3 远程仓库：remote, push & pull

远程仓库是托管在网络服务器上的项目版本库，它使得团队协作成为可能。

- **`git remote`**: 管理你配置的远程仓库。
  - **底层实现**：远程仓库的信息（如 URL）存储在 `.git/config` 文件中。`origin` 是 `git clone` 时为远程仓库默认创建的别名。
  - `git remote add origin <URL>`: 添加一个新的远程仓库。
  - `git remote -v`: 查看所有远程仓库的详细信息。

- **`git push`**: 将本地的提交推送到远程仓库。
  - **底层实现**：将本地 `objects` 数据库中远程仓库没有的对象上传，然后更新远程仓库的 `refs`（如 `refs/heads/master`）。
  - `git push origin master`: 将本地 `master` 分支的提交推送到 `origin` 远程仓库。
  - `git push -u origin master`: `-u` 参数会建立本地 `master` 分支与远程 `origin/master` 分支的“上游（upstream）”关系，之后可以直接使用 `git push` 而无需指定远程和分支。

- **`git fetch` vs `git pull`**: 从远程仓库获取最新代码。
  - **`git fetch`**: **只下载，不合并**。它会下载远程仓库的最新历史记录到你的本地仓库，但**不会**修改你的工作目录。你可以先 `fetch` 下来，检查更新内容，再手动 `merge` 或 `rebase`。
  - **`git pull`**: **下载并合并**。它实际上是 `git fetch` 和 `git merge` 两个命令的组合。它会自动抓取远程更新并尝试将其合并到你当前的分支。对于新手更方便，但 `fetch` 提供了更安全、更可控的工作流。

### 2.4 使用标签 (Tag)

标签用于标记版本历史中某个特定的时间点，最常见的用途是标记软件的发布版本（如 `v1.0.0`）。

#### 命令详解
```bash
# 创建一个轻量标签
git tag v1.0.0

# 创建一个带附注的标签（推荐，包含更多信息）
git tag -a v1.0.1 -m "Release version 1.0.1"

# 默认情况下，`git push` 不会推送标签。必须显式推送：
git push origin v1.0.1

# 或者一次性推送所有本地标签
git push origin --tags
```

#### 底层实现：两种类型的标签

- **轻量标签 (Lightweight Tag)**
  - **实现**：它就是一个永远不会移动的分支。它在 `.git/refs/tags/` 目录下创建一个文件，内容是对应提交的 SHA-1 值。
  - **特点**：它只是一个简单的指针，不存储额外信息。

- **附注标签 (Annotated Tag)**
  - **实现**：它不是一个简单的指针，而是一个完整的 Git 对象，存储在 `.git/objects` 数据库中。它有自己的 SHA-1 值，包含了标签创建者、日期、附注信息，并指向一个 commit 对象。
  - **特点**：被认为是“官方”的，推荐用于所有公共的、重要的发布点，因为它包含了丰富的元数据。