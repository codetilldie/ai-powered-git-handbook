## 第四章：团队协作与最佳实践

掌握了 Git 的基本操作后，下一步就是学习如何在团队中高效、规范地使用它。本章将介绍业界主流的协作模式、编写规范，以及处理协作中最常见的问题——合并冲突。

### 4.1 流行的 Git 工作流

Git 本身非常灵活，但为了保证团队协作的有序性，通常会约定一个统一的“工作流”(Workflow)。

#### 1. GitHub Flow (轻量级工作流)

这是目前最流行、最简单的工作流之一，被 GitHub 自身以及大量团队采用。

**核心原则**:
1.  任何时候 `master` 分支都应该是可部署的（production-ready）。
2.  要进行任何开发（新功能、修 Bug），都必须从 `master` 创建一个**新的、描述清晰的分支** (e.g., `feat/add-login-button`)。
3.  在本地分支上进行开发和提交。
4.  当准备好评审或合并时，向 `master` 分支发起一个 **Pull Request (或 Merge Request)**。
5.  经过团队成员的 Code Review 和自动化测试后，由项目维护者将其合并到 `master` 分支。
6.  合并后，应立即部署 `master` 分支。

**流程图示**:
```
master   o-------------------o-----------o (Deploy)
         |                   |           ^
         | (1. Create Branch)|           |
         v                   |           |
feature  o---o---o---o       | (5. Merge Pull Request)
         |           |       |
         | (3. Commit) |       |
         |           v       |
         '-----------> (4. Open Pull Request)
```

**优点**: 简单、直接、高效，非常适合快速迭代和持续交付的团队。

#### 2. Git Flow (重量级工作流)

这是一个更严格、更复杂的工作流，为大型项目和有明确版本发布周期的项目设计。

**核心分支**:
- `master`: 永远代表着生产环境的稳定代码，只接受来自 `release` 或 `hotfix` 分支的合并。每个 `master` 上的提交都应该用一个版本号 `tag` 标记。
- `develop`: 开发的主分支，包含了所有准备在下一个版本中发布的新功能。

**辅助分支**:
- `feature/*`: 用于开发新功能，从 `develop` 分支创建，最终合并回 `develop` 分支。
- `release/*`: 当 `develop` 分支积累了足够的新功能，准备发布新版本时，从 `develop` 创建。此分支用于发布前的最后测试、Bug 修复和文档生成。完成后，它将**同时合并到 `master` 和 `develop`**。
- `hotfix/*`: 当生产环境的 `master` 分支出现紧急 Bug 时，从 `master` 分支创建。修复完成后，它将**同时合并到 `master` 和 `develop`**。

**流程图示**:
```
master   ------------------o----o-------------------------o----o---- (v1.0) ---- (v1.1)
                            |    ^                         |    ^
                            |    | (5. Merge Hotfix)       |    | (4. Merge Release)
                            |    |                         |    |
hotfix/v1.0.1 ---------------'    |                         |    |
                                  |                         |    |
release/v1.1 --------------------'-------------------------'    |
                                  |                              |
develop  ---o------o---------o----o-------------------------o----o--------------
            |      ^         |    ^                         |
            |      |         |    | (5. Merge Hotfix)       |
            |      |         |    |                         |
            '----(1. Start Feature)                         |
                   |         |                              |
                   |         | (2. Finish Feature)          |
                   v         |                              |
feature/A ---------'---------'                              |
                                                            |
feature/B --------------------------------------------------' (3. Start Release)
```

**优点**: 结构清晰，职责明确，非常适合版本发布周期长、稳定性要求高的大型项目。
**缺点**: 过于复杂，分支繁多，对于敏捷开发和持续部署的团队来说可能过于笨重。

---

### 4.2 编写清晰的 Commit Message

一个清晰的 Commit Message 至关重要，它能让你的同事（以及未来的你）快速理解这次提交的目的。业界广泛采用的一种规范是 **Conventional Commits** (约定式提交)。

**格式**:
```
<类型>[可选的作用域]: <简短描述>

[可选的正文]

[可选的页脚]
```

**常用 `<类型>`**:
- `feat`: 新功能 (feature)
- `fix`: Bug 修复
- `docs`: 文档变更
- `style`: 代码格式（不影响代码逻辑的修改）
- `refactor`: 代码重构（既不是新增功能，也不是修复 Bug）
- `test`: 增加或修改测试
- `chore`: 构建过程或辅助工具的变动

**示例**:
```
feat(auth): 添加用户邮箱登录功能

用户现在可以使用邮箱和密码进行登录。
实现了登录接口的调用和前端状态管理。

Fixes: #123
```
**好处**:
- **可读性强**: 快速了解变更意图。
- **自动化**: 可基于 Commit Message 自动生成 `CHANGELOG`，甚至自动判断版本号升级。

---

### 4.3 Code Review 最佳实践 (Pull Request)

Code Review 是保证代码质量和团队知识共享的关键环节。在 Git 中，这通常通过 **Pull Request (PR)** 或 **Merge Request (MR)** 来实现。

**流程**:
1.  **发起 PR**: 当你的功能分支开发完毕，你向目标分支（如 `main` 或 `develop`）发起一个 PR。
2.  **清晰描述**: 在 PR 中详细说明你做了什么、为什么这么做，以及如何测试。
3.  **评审 (Review)**: 团队成员会查看你的代码变更，提出问题、建议或改进意见。
4.  **讨论与修改**: 你根据反馈进行讨论和修改，并推送新的提交到你的功能分支（PR 会自动更新）。
5.  **批准与合并**: 当至少一到两位同事“批准 (Approve)”后，由项目维护者将 PR 合并到目标分支。

---

### 4.4 如何处理合并冲突

合并冲突 (Merge Conflict) 是团队协作中不可避免的现象。当两个人都修改了同一个文件的同一部分时，Git 无法自动决定该保留哪个版本，于是它会停止合并，并请求你来做最终决定。

**解决步骤**:

1.  **识别冲突**: 当你执行 `git merge` 或 `git pull` 时，如果终端提示 `CONFLICT (content): Merge conflict in <文件名>`，就表示冲突发生了。

2.  **定位冲突标记**: 打开有冲突的文件，你会看到类似下面的标记：
    ```
    <<<<<<< HEAD
    // 这是你当前分支（HEAD）所做的修改
    const greeting = "Hello, World!";
    =======
    // 这是你正在合并进来的那个分支所做的修改
    const greeting = "Hi, World!";
    >>>>>>> other-branch-name
    ```
    - `<<<<<<< HEAD` 到 `=======` 之间是**你当前分支**的内容。
    - `=======` 到 `>>>>>>>` 之间是**另一个分支**的内容。

3.  **手动解决冲突**:
    - **决策**: 你需要根据业务逻辑，决定最终要保留哪部分代码。你可以选择保留其中一个，或者将两者结合，或者写一个全新的版本。
    - **编辑**: **删除所有 Git 的冲突标记** (`<<<<<<<`, `=======`, `>>>>>>>`)，并将文件内容修改为你期望的最终结果。例如，决定使用 "Hello"：
      ```
      const greeting = "Hello, World!";
      ```

4.  **标记为已解决**:
    - 在你确认冲突已解决并且文件内容正确后，执行 `git add <已解决冲突的文件名>`。这个 `add` 操作是在告诉 Git：“我已经解决了这个文件的冲突，请相信我的版本。”

5.  **完成合并**:
    - 当所有冲突文件都已经被 `git add` 之后，执行 `git commit`。Git 会弹出一个预设好的提交信息（通常是 "Merge branch '...' into '...'”），你直接保存并退出即可。
    - **注意**: **不要**在 `commit` 后面加 `-m` 和自定义信息，让 Git 使用默认的合并提交信息。

至此，一次合并冲突就完美解决了。解决冲突需要的是细心和与同事的沟通，而不是恐惧。
